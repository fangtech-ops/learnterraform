locals {
  # We don't need to add 'NarvarTerraformRole' to this list because that role is the creator (by being the role_arn in providers.tf)
  # of this EKS cluster and therefore automatically has full privilege in this cluster.
  #
  # But consider these scenarios:
  #   a) We use kubectl to access this EKS cluster, e.g., 'kubectl get pods'
  #   b) We login to AWS Admin Console and browse to the EKS page. The console will execute the equivalent of 'kubectl' on our behalf
  #      in order to display the details (such as the "Workloads" tab) on the web page.
  #   c) Snippet of ~/.kube/config as a result of 'aws eks update-kubeconfig ...':
  #           - name: arn:aws:eks:us-west-2:106628749228:cluster/eks-devops
  #             user:
  #               exec:
  #                 ...
  #                 args:
  #                 - --region
  #                 - us-west-2
  #                 - eks
  #                 - get-token
  #                 - --cluster-name
  #                 - eks-devops
  #                 command: aws
  #                 env:
  #                 - name: AWS_PROFILE
  #                   value: new-devops
  #
  #      Unlike GKE ('gcloud container clusters get-credentials ...') where a (short term) secret token is written directly into ~/.kube/config,
  #      EKS writes ('aws eks update-kubeconfig ...') the "command to retrieve the token" into ~/.kube/config.
  #      The command is 'aws eks get-token ...' as shown in the above snippet.
  #      When we later execute 'kubectl get pods' (for example), kubectl will execute that command ('aws eks get-token ...') on our behalf to
  #      dynamtically retrieve the token (and cache it under ~/.kube/cache). As shown by the 'env:' element of the above snippet, that command is
  #      going to be executed in whatever identity that's configured under AWS_PROFILE=new-devops.
  #      Although you're free to define your own AWS CLI Profile (AWS_PROFILE=new-devops) to be whatever IAM role or user you'd like, in reality,
  #      that identity is more likely to be the SSO role (a very sensible choice) than the NarvarTerraformRole role.
  #
  # In all above scenarios, the runtime IAM role (equivalent to 'aws sts get-caller-identity') is NOT NarvarTerraformRole;
  # rather, it is the SSO role AWSReservedSSO_AWSAdministratorAccess_93060f8c67728fb7. This SSO role isn't the owner of the EKS cluster, and
  # therefore doesn't (by default) have any privilege as far as kubectl is concerned. This SSO role also doesn't somehow "AssumeRole" to
  # NarvarTerraformRole unless you carry out additional setup or operations (possible but out of scope of our current discussion.)
  #
  # That's why we need to grant privilege to the SSO role here.
  #
  # Byproduct: Because here we are mapping an AWS IAM role (as opposed to an IAM user) to Kubernetes, we no longer need to specify a person's
  # email address like in our old architecture (e.g., prod01). The role names don't change over time; therefore, as people join and leave the company,
  # we no longer need to maintain this list like before (such as in https://github.com/narvar/DevOps/blob/master/charts/aws-auth/prod01.yaml).
  #
  # See:  https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html
  #
  #
  # Tip: For an SSO role, we need to remove the path in the middle of the role ARN, i.e., change the original full ARN
  #      from
  #         arn:aws:iam::106628749228:role/aws-reserved/sso.amazonaws.com/us-west-2/AWSReservedSSO_AWSAdministratorAccess_93060f8c67728fb7
  #      to
  #         arn:aws:iam::106628749228:role/AWSReservedSSO_AWSAdministratorAccess_93060f8c67728fb7
  #
  #      See:  https://docs.aws.amazon.com/eks/latest/userguide/troubleshooting_iam.html#security-iam-troubleshoot-ConfigMap
  aws_auth_append = var.aws_auth_append
}

# This creates a file in Github repo 'flux-infra'. It will then be applied by Flux after 31-flux-bootstrap.tf runs 'flux bootstrap ...'.
resource "github_repository_file" "aws-auth" {
  repository          = "flux-infra"
  branch              = "master"
  file                = var.aws_auth_file
  commit_message      = var.github_repository_file_cm_commit_message
  commit_author       = "Narvar terraform user from Github repo terraform-aws-accounts"
  commit_email        = "terraform@narvar.com"
  overwrite_on_create = true

  # When adding a Node Group (by ../30-eks1/eks.tf), AWS automatically creates/pupulates the aws-auth ConfigMap with
  # the content suitable for that Node Group. The terraform module outputs that (existing) aws-auth yaml as a variable (string).
  # That output variable is handy for us now to prepend and append to.
  content = <<EOT
# This file is automatically generated and committed to Github 'flux-infra' by this terraform:
#   https://github.com/narvar/terraform-aws-accounts/blob/main/admin/devops/40-eks1-bootstrap/30-flux-config-map-aws-auth.tf
#
# Don't edit it by hand in the 'flux-infra' repo.

${data.terraform_remote_state.eks.outputs.aws_auth_configmap_yaml}
${local.aws_auth_append}
EOT

}
